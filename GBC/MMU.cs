using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GBC
{
    public class MMU
    {
        public struct MemoryBankController { public int RomBank, RamBank, RamOn, Mode; };
        ///<summary> memory managment unit </summary>
        public Stack<byte> stack = new Stack<byte>();
        
        bool inBios = true;

        // memory regions
        byte[] bios = new byte[] // bios
        {
            0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
            0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
            0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
            0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
            0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
            0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
            0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
            0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
            0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
            0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
            0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
            0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
            0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
            0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
            0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
            0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
        };
        byte[] ioReset = new byte[] {
        0x0F, 0x00, 0x7C, 0xFF, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x80, 0xBF, 0xF3, 0xFF, 0xBF, 0xFF, 0x3F, 0x00, 0xFF, 0xBF, 0x7F, 0xFF, 0x9F, 0xFF, 0xBF, 0xFF,
        0xFF, 0x00, 0x00, 0xBF, 0x77, 0xF3, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
        0x91, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x7E, 0xFF, 0xFE,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF, 0xC1, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
        0xF8, 0xFF, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
        0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
        0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
        0x45, 0xEC, 0x52, 0xFA, 0x08, 0xB7, 0x07, 0x5D, 0x01, 0xFD, 0xC0, 0xFF, 0x08, 0xFC, 0x00, 0xE5,
        0x0B, 0xF8, 0xC2, 0xCE, 0xF4, 0xF9, 0x0F, 0x7F, 0x45, 0x6D, 0x3D, 0xFE, 0x46, 0x97, 0x33, 0x5E,
        0x08, 0xEF, 0xF1, 0xFF, 0x86, 0x83, 0x24, 0x74, 0x12, 0xFC, 0x00, 0x9F, 0xB4, 0xB7, 0x06, 0xD5,
        0xD0, 0x7A, 0x00, 0x9E, 0x04, 0x5F, 0x41, 0x2F, 0x1D, 0x77, 0x36, 0x75, 0x81, 0xAA, 0x70, 0x3A,
        0x98, 0xD1, 0x71, 0x02, 0x4D, 0x01, 0xC1, 0xFF, 0x0D, 0x00, 0xD3, 0x05, 0xF9, 0x00, 0x0B, 0x00
        };

        byte[] rom;// rom banks
        byte[] wram = new byte[8192]; // working ram
        byte[] eram = new byte[32768]; // external ram
        byte[] zram = new byte[127]; // zero-page ram, high speed memory
        public byte[] vram = new byte[8192];
        public byte[] oam = new byte[256]; // sprite data

        MemoryBankController[] mbc = new MemoryBankController[4];

        public byte InterruptFlags = 0;
        public byte InterruptEnable = 0;
        private ushort ramoffs;
        private ushort romoffs;
        private byte carttype;

        public CPU cpu;
        public GPU gpu;

        public KeyPad Keys = new KeyPad();

     
        public void reset()
        {
            for (int i = 0; i < 8192; i++) wram[i] = 0;
            for (int i = 0; i < 32768; i++) eram[i] = 0;
            for (int i = 0; i < 127; i++) zram[i] = 0;

            inBios = true;
            InterruptEnable = 0;
            InterruptFlags = 0;

            carttype = 0;
            
            romoffs = 0x4000;
            ramoffs = 0;
            Keys = new KeyPad();
        }

        public void LoadRom(byte[] rom)
        {
            this.rom = rom;   
        }

      
       public byte RB(ushort address)
        {          
            if (inBios)
            {
                if (address < 0x0100)
                    return bios[address];
                else if (cpu.IP == 0x0101)
                {
                    inBios = false;

                }
            }
            if (address <= 0x7fff)
                return rom[address];

            else if (address >= 0xa000 && address <= 0xbfff)
                return eram[address - 0xa000];

            else if (address >= 0x8000 && address <= 0x9fff)
                return vram[address - 0x8000];

            else if (address >= 0xc000 && address <= 0xdfff)
                return wram[address - 0xc000];

            else if (address >= 0xe000 && address <= 0xfdff)
                return wram[address - 0xe000];

            else if (address >= 0xfe00 && address <= 0xfeff)
                return oam[address - 0xfe00];

            else if (address == 0xff04) return (byte)new Random().Next(0, 255);

            else if (address == 0xff40) return gpu.gpu.control;
            else if (address == 0xff42) return gpu.gpu.scrollY;
            else if (address == 0xff43) return gpu.gpu.scrollX;
            else if (address == 0xff44) return gpu.gpu.scanline; // read only

            else if (address == 0xff00)
            {
                return (byte)(0xc0 | Keys.RB(address));         
            }

            else if (address == 0xff0f) return InterruptFlags;
            else if (address == 0xffff) return InterruptEnable;

            else if (address >= 0xff80 && address <= 0xfffe)
                return zram[address - 0xff80];

            else if (address >= 0xff00 && address <= 0xff7f)
                Keys.RB(address);     

            return 0;
        }


        public ushort RW(ushort addr) // read word.
        {
            ushort W = RB(addr);
            W += ((ushort)(RB((ushort)(addr+1)) << 8));
            return W;
        }
        public void WB(ushort address, byte value)
        {
           
            if (address >= 0xa000 && address <= 0xbfff)
                wram[address - 0xa000] = value;

            else if (address >= 0x8000 && address <= 0x9fff)
            {
                vram[address - 0x8000] = value;
                if (address <= 0x97ff)
                    gpu.updatetile(address, value);
            }

            if (address >= 0xc000 && address <= 0xdfff)
                wram[address - 0xc000] = value;

            else if (address >= 0xe000 && address <= 0xfdff)
                wram[address - 0xe000] = value;

            else if (address >= 0xfe00 && address <= 0xfe9f)
                oam[address - 0xfe00] = value;

            else if (address >= 0xff80 && address <= 0xfffe)
                zram[address - 0xff80] = value;

            else if (address == 0xff40)
            {
                gpu.gpu.control = value;

            }
            else if (address == 0xff42)
            {
                gpu.gpu.scrollY = value;
              
            }
            else if (address == 0xff43) gpu.gpu.scrollX = value;
            else if (address == 0xff46)
                copy(0xfe00, (ushort)(value << 8), 160); // OAM DMA

            else if (address == 0xff47)
            { // write only
                //value = 0xF3;
                for (int i = 0; i < 4; i++)
                    gpu.backgroundPalette[i] = gpu.palette[(value >> (i * 2)) & 3];
            }

            else if (address == 0xff48)
            { // write only
                int i;
                for (i = 0; i < 4; i++) gpu.spritePalette[0,i] = gpu.palette[(value >> (i * 2)) & 3];
            }

            else if (address == 0xff49)
            { // write only
                int i;
                for (i = 0; i < 4; i++) gpu.spritePalette[1,i] = gpu.palette[(value >> (i * 2)) & 3];
            }

            else if (address >= 0xff00 && address <= 0xff7f)
                Keys.WB(address, value);
            else if (address == 0xff0f)
                InterruptFlags = value;
            else if (address == 0xffff)
                InterruptEnable = value;
        }
        void copy(ushort destination, ushort source, int length)
        {
            ushort i;
            for (i = 0; i < length; i++) WB((ushort)(destination + i), RB((ushort)(source + i)));
        }
       

        public void WW(ushort addr, ushort value) // write word to memory.
        {
            WB(addr, (byte)(value & 255)); WB((ushort)(addr + 1), (byte)( value >> 8));
        }

    }
}
